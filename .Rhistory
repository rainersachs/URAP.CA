}
return(a^2)
}
L_NTE1 = L_function(NTE1_function, eta0 = 0.00011, eta1 = 0.007, sig0 = 6.12, kap = 796)
L_NTE2 = L_function(NTE2_function, eta0 = 0.00047, eta1 = 0.011, sig0 = 6.75, kap = 590)
L_IDER = L_function(IDER, eta0 = eta00, eta1 = eta10, sig0 = sig00, kap = kap0)
#Since all models are weighted least square regression, will weight our model with our weights to get the WRSS (weighted residual squared sum)
WRSS_NTE1 = sum((1/modified_df$error^2)*L_NTE1)
WRSS_NTE2 = sum((1/modified_df$error^2)*L_NTE2)
WRSS_IDER = sum((1/modified_df$error^2)*L_IDER)
#functions for AIC and BIC calculation for Weighted Least Square regression
AIC_function = function(RSS, k = 4, n = length(modified_df[ , 1])) {
n + n*log(2*pi) + n*log(RSS/n) + 2*(k+1)
}
BIC_function = function(n = length(modified_df[, 1]), k = 4, RSS) {
n + n*log(2*pi) + n*log(RSS/n) + log(n)*(k+1)
}
NTE1_AIC = AIC_function(RSS = WRSS_NTE1)
NTE2_AIC = AIC_function(RSS = WRSS_NTE2)
IDER_AIC = AIC_function(RSS = WRSS_IDER)
NTE1_BIC = BIC_function(RSS = WRSS_NTE1)
NTE2_BIC = BIC_function(RSS = WRSS_NTE2)
IDER_BIC = BIC_function(RSS = WRSS_IDER)
information_critera_df = data.frame(AIC = c(NTE1_AIC, NTE2_AIC, IDER_AIC), BIC = c(NTE1_BIC, NTE2_BIC, IDER_BIC), row.names = c("NTE1 model", "NTE2 model", "IDER model"))
information_critera_df ## RKS runs well up to here. Lots of checks made 8/12/2017
# #Baseline no-synergy/no-antagonism MIXDER  based on any input
MIXDER_function = function(r, L, Z.b, d = seq(0, 0.2, by = 0.001), eta0 = eta00, eta1 = eta10, sig0 = sig00 ,kap = kap0) {
dE=function(yini,State,Pars){
eta0 = eta0; eta1 = eta1; sig0 = sig0; kap = kap
with(as.list(c(State, Pars)), {
P = vector(length = length(L))
sig = vector(length = length(L))
etaa = vector(length = length(L))
u = vector(length = length(L))
for (i in 1:length(L)) {
P[i] = (1-exp(-Z.b[i]/kap))^2
sig[i] = sig0*P[i] + 0.041/6.24*L[i]*(1-P[i])
etaa[i] = eta0*L[i]*exp(-eta1*L[i])
u[i] = uniroot(function(d) sig[i]*6.24*d/L[i]*(1-exp(-1024*d/L[i])) + etaa[i]*(1-exp(-10^5*d)) - I, lower = 0, upper = 1, extendInt = "yes", tol = 10^-10)$root
}
dI = vector(length = length(L))
for (i in 1:length(L)) {
dI[i] = r[i]*(sig[i]*6.24/L[i]*exp(-1024*u[i]/L[i])*(exp(1024*u[i]/L[i]) + 1024*u[i]/L[i] - 1) + etaa[i]*10^5*exp(-10^5*u[i]))
}
dI = sum(dI)
return(list(c(dI)))
})
}
pars = NULL; yini = c(I= 0); d = d
out = ode(yini,times = d, dE, pars, method = "radau")
return(out)
}
#Graphs for NTE1 and our IDER models: 12_ion figure
#When creating any sort of MIXDER figures we use this IDER now without the background effect then add the background effect at the end.
IDER = function(d, L, Z.b, eta0 = eta00, eta1 = eta10, sig0 = sig00, kap = kap0) {
P = (1-exp(-Z.b/kap0))^2
sig = sig0*P + 0.041/6.24*L*(1-P)
eta = eta0*L*exp(-eta1*L)
sig*6.24*d/L*(1-exp(-1024*d/L)) + eta*(1-exp(-10^5*d))#sig*6.24*d/L*(1-exp(-1024*d/L)) + eta*(1-exp(-.5*10^3*d))#don't use
}
r=rep(1/6,6);L = c(75, 100, 125, 175, 195, 240); Z.b = c(595, 690, 770, 1075, 1245, 1585);dose=seq(0,.4,by=0.001)
MX=MIXDER_function(r,L,Z.b,d=dose)#for this mixture can't go much above 0.6#
plot(MX[,1],MX[,2],type='l',bty='l',col='red',ann='F',ylim=c(0,.10))
for (ii in 1:length(L)){lines(dose,IDER (dose,L[ii],Z.b[ii]),col='green')}
#SEA
SEA=function(d){
IDER(d/6,L[1],Z.b[1])+IDER(d/6,L[2],Z.b[2])+IDER(d/6,L[3],Z.b[3])+IDER(d/6,L[4],Z.b[4])+IDER(d/6,L[5],Z.b[5])+IDER(d/6,L[6],Z.b[6])
}
lines(dose,SEA(dose),lty=2)
#lines(dose,sum(SEA))
#Comparing the NTE1 model in 16Cacao with our NASA SNTE model
#Use these dose points to generate the curves necessary. Had to include a lot more dose points at lower doses where it is very sensitive to change
# d_O = c(0, 1e-6*(1:9), 1e-5*(1:9), 1e-4*(1:9), 1e-3*(1:9), 1e-2*(1:9), 0.01*(10:40))
# d_1 = c(0, 1e-6*(1:9), 1e-5*(1:9), 1e-4*(1:9), 1e-3*(1:9), 1e-2*(1:9), 0.01*(10:15))
# d_2 = c(0, 1e-6*(1:9), 1e-5*(1:9), 1e-4*(1:9), 1e-3*(1:300))
# plot(c(0,.3),c(0,0.04), bty='l', ann='F')
# lines(d_2,IDER(d_2,240,1585), bty='l', ann='F')
# #setEPS()
# postscript("NTE1_model test.eps", width = 5, height = 7)
# par(mfrow=c(2,1))
#
# plot(x = big_df$d[1:9]*100, y = big_df$CA[1:9]*100, main = "Oxygen", ylim = c(0, 10),pch=19, ylab = "CA", xlab = "Dose (cGy)")
# arrows(big_df$d[1:9]*100, big_df$errorbar_lower[1:9]*100, big_df$d[1:9]*100, big_df$errorbar_upper[1:9]*100, length=0.02, angle=90, code=3)
# lines(x = d_O*100, y = 100*(0.00071 + IDER(d = d_O, L = 75, Z.b = 595)), col = "red")
# lines(x = d_O*100, y = 100 * NTE1_function(d = d_O, L= 75, Z.b = 595), col = "blue", lty = 2)
#
# plot(x = big_df$d[1:7]*100, y = big_df$CA[1:7]*100, main = "Oxygen",pch=19, ylab = "CA", xlab = "Dose (cGy)", ylim = c(0, 4), xlim = c(0, 15))
# arrows(big_df$d[1:7]*100, big_df$errorbar_lower[1:7]*100, big_df$d[1:7]*100, big_df$errorbar_upper[1:7]*100, length=0.02, angle=90, code=3)
# lines(x = d_1*100, y = 100*(0.00071 + IDER(d = d_1, L = 75, Z.b = 595)), col = "red")
# lines(x = d_1*100, y = 100 * NTE1_function(d = d_1, L= 75, Z.b = 595), col = "blue", lty = 2)
#
# dev.off()
#The following code includes the Monte Carlo CI1 and 2. Monte Carlo CI will use the variance covariance matrix. Monte Carlo CI2 will not hence it will give a boarder interval.
#Monte Carlo using the error bars from summary()
NN <- 1000
eta0_MC_2 = rnorm(NN, mean = eta00, sd = 4.631e-05)
eta1_MC_2 = rnorm(NN, mean = eta10, sd = 1.617e-04)
sig0_MC_2 = rnorm(NN, mean = sig00, sd = 1.966e+00)
kap_MC_2 = rnorm(NN, mean = kap0, sd = 2.628e+02)
kap_MC_2[kap_MC_2 <= 1e-6] = 1e-5
# You will get broader CI by running CI_function_MIXDER_MC_2.
MM = 500
CI_function_MIXDER_MC_2 = function(d, d_interested, r, interval = 0.95, L, Z.beta) {
MIXDER_curve = list(0)
for (i in 1:MM) {
MIXDER_curve[[i]] = MIXDER_function(r = r, d = d, L = L, Z.b = Z.b, eta0 = eta0_MC_2[i], eta1 = eta1_MC_2[i], sig0 = sig0_MC_2[i], kap = kap_MC_2[i])
}
info = vector(length = 0)
for (i in 1:MM) {
info = c(info, MIXDER_curve[[i]][, 2][2])
}
info = sort(info)
lower_bound = info[(1-interval)/2*500]
upper_bound = info[(interval + (1-interval)/2)*500]
CI = c(lower_bound, upper_bound)
return(CI)
}
#note because our last parameter were less significant when inputting our variance covariance matrix the parameters had to actually be readjusted to fix for negative value. This is important because if kap parameter went negative our model is nonsensical. (Luckily the fix was only for exactly 15 out of 500 MC samples or only roughly 3%)
#This is a general CI_function where you just get a CI for a specific dose point for any synergy analysis using the monte carlo simulations using vcov().
CI_function_MIXDER = function(d, r, interval = 0.95, L, Z.beta) {
MIXDER_curve = list(0)
for (i in 1:500) {
MIXDER_curve[[i]] = MIXDER_function(r = r, d = d, L = L, Z.b = Z.b, eta0 = eta0_MC[i], eta1 = eta1_MC[i], sig0 = sig0_MC[i], kap = kap_MC[i])
}
info = vector(length = 0)
for (i in 1:500) {
info = c(info, MIXDER_curve[[i]][, 2][2])
}
info = sort(info)
lower_bound = quantile(info,(1-interval)/2)
upper_bound = quantile(info,1-(1-interval)/2)
CI = c(lower_bound, upper_bound)
return(CI)
}
# We don't actually need the above CI_Function_MIXDER
# Sample parameters from their distributions.
set.seed(19970101)
sig = vcov(IDER_model)
monte_carlo_parameters = rmvnorm(n = 500, mean = c(eta0 = eta00, eta1 = eta10, sig0 = sig00, kap = kap0), sigma = sig)
eta0_MC = monte_carlo_parameters[, 1]
eta1_MC = monte_carlo_parameters[, 2]
sig0_MC = monte_carlo_parameters[, 3]
kap_MC = monte_carlo_parameters[, 4]
kap_MC[kap_MC <= 1e-6] = 1e-5
#MIXDER of iron 2.
out = MIXDER_function(r = rep(1/2, times = 2), L = c(100, 175), Z.b = c(690, 1075), d = c(seq(0, 0.009, 0.001), seq(0.01, 0.5, by = 0.01)),eta0 = eta00, eta1 = eta10, sig0 = sig00, kap = kap0)
two_ion_MIXDER1 = data.frame(d = out[, 1], CA = out[, 2] + 0.00071)
two_ion_MIXDER2 = data.frame(d = out[, 1][seq(1,60, by = 5)], CA = out[, 2][seq(1,60, by = 5)] + 0.00071)
d1 =two_ion_MIXDER1$d
d2 =two_ion_MIXDER2$d
# Monte Carlo of using 60 doses for two_ion.
ninty_five_CI_lower = vector(length = length(d1))
ninty_five_CI_upper = vector(length = length(d1))
for (i in 1:length(d1)){
info = vector(length = 0)
for (j in 1:500){
info = c(info, MIXDER_function(r = rep(1/2, times = 2), c(0,   two_ion_MIXDER1$d[i]),L=c(100, 175), Z.b = c(690, 1075), eta0 = eta0_MC[j], eta1 = eta1_MC[j], sig0 = sig0_MC[j], kap = kap_MC[j])[,2][2])
}
info = sort(info)
ninty_five_CI_lower[i] = quantile(info,(1-0.95)/2) + 0.00071
ninty_five_CI_upper[i] = quantile(info,1-(1-0.95)/2) + 0.00071
}
two_ion_MIXDER1$CI_lower = ninty_five_CI_lower
two_ion_MIXDER1$CI_upper = ninty_five_CI_upper
#Get the simple effect additivity MIXDER
two_ion_MIXDER1$simpleeffect = IDER(d = 0.5*d1, L = 100, Z.b = 690) + IDER(d = 0.5*d1, L = 175, Z.b = 1075) + 0.00071
#Get the individual IDERS
two_ion_MIXDER1$silicon = IDER(d = d1, L = 100, Z.b = 690) + 0.00071
two_ion_MIXDER1$ironsix = IDER(d = d1, L = 175, Z.b = 1075) + 0.00071
save(two_ion_MIXDER1, file = "two_ion_95%.Rda")
d1 <- two_ion_MIXDER1$d
CA1 <- two_ion_MIXDER1$CA
simpleeffect1 <- two_ion_MIXDER1$simpleeffect
silicon1 <- two_ion_MIXDER1$silicon
ironsix1 <- two_ion_MIXDER1$ironsix
plot(x = d1 * 100, y = CA1 * 100, type = "l", col = "red")
lines(x = d1 * 100, y = simpleeffect1 * 100, col = "black", lty = 2, lwd = 0.5) +
lines(x = d1 * 100, y = silicon1* 100, col = "green")
lines(x = d1 * 100, y = ironsix1* 100, col = "green")
lines(x= d1*100 , y = two_ion_MIXDER1$CI_upper * 100, lty = 'dashed', col = 'red')
lines(x= d1*100 , y = two_ion_MIXDER1$CI_lower * 100, lty = 'dashed', col = 'red')
polygon(c(d1*100,rev(d1*100)),c(two_ion_MIXDER1$CI_lower * 100, rev(two_ion_MIXDER1$CI_upper * 100)),col = rgb(1, 0, 0,0.5), border = NA)
#Then the 95% CI multivariate MC simulated ribbon for 13 doses for 2 ion.
ninty_five_CI_lower = vector(length = length(d2))
ninty_five_CI_upper = vector(length = length(d2))
for (i in 1:length(d2)){
info = vector(length = 0)
for (j in 1:500){
info = c(info, MIXDER_function(r = rep(1/2, times = 2), c(0,   two_ion_MIXDER2$d[i]),L=c(100, 175), Z.b = c(690, 1075), eta0 = eta0_MC[j], eta1 = eta1_MC[j], sig0 = sig0_MC[j], kap = kap_MC[j])[,2][2])
}
info = sort(info)
ninty_five_CI_lower[i] = quantile(info,(1-0.95)/2) + 0.00071
ninty_five_CI_upper[i] = quantile(info,1-(1-0.95)/2) + 0.00071
}
two_ion_MIXDER2$CI_lower = ninty_five_CI_lower
two_ion_MIXDER2$CI_upper = ninty_five_CI_upper
#Get the simple effect additivity MIXDER
two_ion_MIXDER2$simpleeffect = IDER(d = 0.5*d2, L = 100, Z.b = 690) + IDER(d = 0.5*d2, L = 175, Z.b = 1075) + 0.00071
#Get the individual IDERS
two_ion_MIXDER2$silicon = IDER(d = d2, L = 100, Z.b = 690) + 0.00071
two_ion_MIXDER2$ironsix = IDER(d = d2, L = 175, Z.b = 1075) + 0.00071
save(two_ion_MIXDER2, file = "two_ion_95%.Rda")
d2 <- two_ion_MIXDER2$d
CA1 <- two_ion_MIXDER2$CA
simpleeffect1 <- two_ion_MIXDER2$simpleeffect
silicon1 <- two_ion_MIXDER2$silicon
ironsix1 <- two_ion_MIXDER2$ironsix
plot(x = d2 * 100, y = CA1 * 100, type = "l", col = "red")
lines(x = d2 * 100, y = simpleeffect1 * 100, col = "black", lty = 2, lwd = 0.5) +
lines(x = d2 * 100, y = silicon1* 100, col = "green")
lines(x = d2 * 100, y = ironsix1* 100, col = "green")
lines(x= d2*100 , y = two_ion_MIXDER2$CI_upper * 100, lty = 'dashed', col = 'red')
lines(x= d2*100 , y = two_ion_MIXDER2$CI_lower * 100, lty = 'dashed', col = 'red')
polygon(c(d2*100,rev(d2*100)),c(two_ion_MIXDER2$CI_lower * 100, rev(two_ion_MIXDER2$CI_upper * 100)),col = rgb(1, 0, 0,0.5), border = NA)
#This is for the six_ion synergy analysis incorporating our monte carlo simulations with the yellow ribbon as the 95% confidence interval using our monte carlo simulated parameters with two panels for two methods of the MC simulation. Similarly, blues curves are individual IDERs and red curve the mixed IDER and the black the simple effect addtivity curve.
#First the MIXDER of the true curve
out = MIXDER_function(r = rep(1/6, times = 6), L = c(75, 100, 125, 175, 195, 240), Z.b = c(595, 690, 770, 1075, 1245, 1585), d = c(seq(0, 0.01, 0.001), seq(0.01, 0.4, by = 0.01)))
six_ion_MIXDER3 = data.frame(d = out[, 1][seq(1,51, by = 5)], CA = out[, 2][seq(1,51, by = 5)] + 0.00071)
d3 = six_ion_MIXDER3$d
#Then the 95% CI multivariate MC simulated ribbon for 11 doses.
ninty_five_CI_lower = vector(length = length(d3))
ninty_five_CI_upper = vector(length = length(d3))
for (i in 1:length(d3)){
info = vector(length = 0)
for (j in 1:500){
info = c(info, MIXDER_function(r = rep(1/6, times = 6), c(0,  six_ion_MIXDER3$d[i]),L = c(75, 100, 125, 175, 195, 240), Z.b = c(595, 690, 770, 1075, 1245, 1585), eta0 = eta0_MC[j], eta1 = eta1_MC[j], sig0 = sig0_MC[j], kap = kap_MC[j])[,2][2])
}
info = sort(info)
ninty_five_CI_lower[i] = quantile(info,(1-0.95)/2) + 0.00071
ninty_five_CI_upper[i] = quantile(info,1-(1-0.95)/2) + 0.00071
}
six_ion_MIXDER3$CI_lower = ninty_five_CI_lower
six_ion_MIXDER3$CI_upper = ninty_five_CI_upper
#Get the simple effect additivity MIXDER
six_ion_MIXDER3$simpleeffect = IDER(d = 1/6*d3, L = 125, Z.b = 770) + IDER(d = 1/6*d3, L = 175, Z.b = 1075) + IDER(d = 1/6*d3, L = 75, Z.b = 595) + IDER(d = 1/6*d3, L = 100, Z.b = 690) + IDER(d = 1/6*d3, L = 195, Z.b = 1245) + IDER(d = 1/6*d3, L = 240, Z.b = 1585) + 0.00071
#Get the individual IDERS
six_ion_MIXDER3$oxygen = IDER(d = d3, L = 75, Z.b = 595) + 0.00071
six_ion_MIXDER3$silicon = IDER(d = d3, L = 100, Z.b = 690) + 0.00071
six_ion_MIXDER3$titanium = IDER(d = d3, L = 125, Z.b = 770) + 0.00071
six_ion_MIXDER3$ironsix = IDER(d = d3, L = 175, Z.b = 1075) + 0.00071
six_ion_MIXDER3$ironfour = IDER(d = d3, L = 195, Z.b = 1245) + 0.00071
six_ion_MIXDER3$ironthree = IDER(d = d3, L = 240, Z.b = 1585) + 0.00071
d2 <- six_ion_MIXDER3$d
CA2 <- six_ion_MIXDER3$CA
simpleeffect2 <- six_ion_MIXDER3$simpleeffect
silicon2 <- six_ion_MIXDER3$silicon
titanium2 <- six_ion_MIXDER3$titanium
ironthree2 <- six_ion_MIXDER3$ironthree
ironfour2 <- six_ion_MIXDER3$ironfour
ironsix2 <- six_ion_MIXDER3$ironsix
oxygen2 <- six_ion_MIXDER3$oxygen
plot(x = d2 * 100, y = CA2 * 100, type = "l", col = "red")
lines(x = d2 * 100, y = simpleeffect2 * 100, col = "black", lty = 2, lwd = 0.5) +
lines(x = d2 * 100, y = silicon2* 100, col = "green")
lines(x = d2 * 100, y = titanium2* 100, col = "green")
lines(x = d2 * 100, y = ironthree2* 100, col = "green")
lines(x = d2 * 100, y = ironfour2* 100, col = "green")
lines(x = d2 * 100, y = ironsix2* 100, col = "green")
lines(x = d2 * 100, y = oxygen2* 100, col = "green")
lines(x= d2*100 , y = six_ion_MIXDER3$CI_upper * 100, lty = 'dashed', col = 'red')
lines(x= d2*100 , y = six_ion_MIXDER3$CI_lower * 100, lty = 'dashed', col = 'red')
polygon(c(d2*100,rev(d2*100)),c(six_ion_MIXDER3$CI_lower * 100, rev(six_ion_MIXDER3$CI_upper * 100)),col = rgb(1, 0, 0,0.5), border = NA)
#Then the 95% CI for the MC simulated independent gaussians
ninty_five_CI_lower_two = vector(length = 0)
ninty_five_CI_upper_two = vector(length = 0)
a = vector(length = 0)
for (i in 2:length(d3)) {
a = CI_function_MIXDER_MC_2(d = c(0, six_ion_MIXDER3$d[i]), d_interested = six_ion_MIXDER3$d[i], r = rep(1/6, times = 6), L = c(75, 100, 125, 175, 195, 240), Z.b = c(595, 690, 770, 1075, 1245, 1585))
print(a)
ninty_five_CI_lower_two = c(ninty_five_CI_lower_two, a[1])
ninty_five_CI_upper_two = c(ninty_five_CI_upper_two, a[2])
}
knitr::opts_chunk$set(echo = TRUE)
library(deSolve) # package for solving differential equations
library(minpack.lm) # package for non-linear regression #rks to laz: I think we probably can just use nls() in stats, not nlsLM from linpack. Please check in R documentation if there is any functional difference at all
library(mvtnorm) #package for calculating confidence intervals by Monte Carlo simulation based on variance-covariance matrices #rks to laz: I added to comment.Please check that my addition is OK.
library(dplyr)
library(ggplot2)
rm(list=ls())
#Create dataframes that store the fibroblast WGE simple CA data used in 16Cacao
#L and Z.b are rounded to the nearest 5.
Oxygen = data.frame(d = c(0, .0125, .025, .05, .075, .1, .2, .3, .4, .8),CA = c(.72, .96, 2.83, 4.7, 4.01, 8.41, 16.8, 40, 42.8, 94.4), ion = "O", Z = 8, L = 75, Z.b = 595)# Some GCR components are high-speed Oxygen nuclei that are almost fully ionized. d=dose; CA are per hundred cells. Z=atomic charge; L=LET; Z.b = Z^2/beta*^2
Si = data.frame(d = c(0, .02, .04, .06, .08, .1, .12, .15, .2, .3, .4, .6, .8, 1, 1.2, 1.5), CA = c(1.08, 2.04, 3.83, 4.57, 5.96, 4.78, 5.48, 13.88, 13.14, 27.0, 25.9, 59.5, 36.8, 81.8, 117.8, 123.2), ion = "Si", Z = 14, L = 100, Z.b = 690)
Fe600 = data.frame(d = c(0, 0.005, .01, .02, .04, .07, .1, .15, .2, .3, .4, .6, 1, 1.5), CA = c(1.01, 2.05, 2.33, 3.9, 3.51, 3.27, 5.71, 10.7, 9.14, 12.2, 21, 24.9, 43.6, 93.9), ion = "Fe600", Z = 26, L = 175, Z.b = 1075) #600 refers to the energy in MeV per atomic mass unit in this Iron beam
big_df = rbind(Oxygen, Si, Fe600)
big_df$error = c(.42, .48, 1.16, 1.36, 0.94, 2.54, 2.65, 5.9, 6.85, 13.6, .21, .34, .70, .95, .68, 1.07, 1.04, 2.38, 1.72, 4.77, 0.87, 9.18, 2.75, 9.85, 17, 13.2, 0.43, 0.48, 0.67, 0.8, 0.73, 0.75, 1.72, 1.95, 2.89, 2.34, 4.37, 5.08, 8.25, 18.8) #error bars for the CA measurementsx
#Next modify the data frame to get rid of the zero dose points. Background CA frequency was determined seperately.
modified_df = big_df[big_df$d != 0, ]
modified_df$CA = modified_df$CA*0.01 #Change it into per cell from per 100 cells
modified_df$error = modified_df$error*0.01
big_df$CA = big_df$CA * 0.01
big_df$error = big_df$error * 0.01
big_df$errorbar_lower = big_df$CA - big_df$error
big_df$errorbar_upper = big_df$CA + big_df$error
eta_1s <- c(0.97, -0.5, -0.75)/100
eta_2s <- c(3.11, 2.94, 1.47)/100
L <- c(175, 100, 75)
#eta <- c(0.46, 0.26, 0.75, 0.07, 1.21)/100
#eta <- c(1.07, 0.79, 1.18, 0.97, 2.32)/100
#L <- c(175, 195, 220, 100, 75)
eta_nte1 <- data.frame(eta = eta_1s, L)
eta_nte2 <- data.frame(eta = eta_2s, L)
eta_function <- function(L, eta0, eta1){
eta0 * L * exp(-eta1 * L)
}
NTE1_etafit <- nlsLM(eta ~ eta_function(L, eta0, eta1), data = eta_nte1, start = list(eta0 = 0.001, eta1 = 0.01))
NTE2_etafit <- nlsLM(eta ~ eta_function(L, eta0, eta1), data = eta_nte2, start = list(eta0 = 0.001, eta1 = 0.01))
summary(NTE1_etafit)
summary(NTE2_etafit)
d_0=10^-5 # nominal dose where NTE are saturating, so that for d>>d_0 further increases are due to TE
TE_function = function(d, L, alpha, beta) {
#rks to laz and spw. This is proposed new TE-only model for lymphocytes
Flux=6.242*d/L # Eq. (5a) in 18_dev_bet; a model-independent equation for particle flux
A = 30 #The area of the cell nucleus for lymphocytes
H=A*Flux
0 + (alpha + beta * Flux)*(1-exp(-H))
}
new_Q_IDER_model_TEonly = nlsLM(CA ~ TE_function(d, L, alpha, beta), data = modified_df, start = list(alpha = 0.5, beta=5),
weights = (1/(modified_df$error)^2))
NTE_Q_function = function(d, L, eta0, eta1, beta) {
Flux=6.242*d/L # rks to laz and spw. This is proposed NTE-TE model for lymphocytes
A = 30 #The area of the cell nucleus for lymphocytes
H=A*Flux
eta = eta0*L*exp(-eta1*L) # Eq. 9 in 18dev_bet
0.0104 + beta*Flux*(1-exp(-H)) + eta*(1-exp(-d/d_0))  #0.00071 + sig*6.24*d/L*(1-exp(-1024*d/L)) + eta*(1-exp(-10^3*d))#don't use
}
#nls (non-linear least square) method to get the parameters needed (4 parameter estimation)
new_Q_IDER_model = nlsLM(CA ~ NTE_Q_function(d, L, eta0, eta1, beta), data = modified_df, start = list(eta0 = 0.001, eta1 = 0.01, beta=3),
weights = (1/(modified_df$error)^2))
NTE_LQ_function = function(d, L, eta0, eta1,alpha, beta) {
Flux=6.242*d/L # rks to laz and spw. This is proposed NTE-TE model for lymphocytes
A = 30 #The area of the cell nucleus for lymphocytes
H=A*Flux
eta = eta0*L*exp(-eta1*L) # Eq. 9 in 18dev_bet
0.0104 +(alpha/d+ beta)*Flux*(1-exp(-H)) + eta*(1-exp(-d/d_0))
}
new_LQ_IDER_model = nlsLM(CA ~ NTE_LQ_function(d, L, eta0, eta1,alpha, beta), data = modified_df, start = list(eta0 = 0.001, eta1 = 0.01, alpha=0.3, beta=2),
weights = (1/(modified_df$error)^2))
IDER = function(d, L, Z.b, eta0, eta1, sig0, kap) {
Flux=6.242*d/L
A = 30 #The area of the cell nucleus for lymphocytes
H=A*Flux
P = (1-exp(-Z.b/kap))^2 #Eq. (7A) in 18_dev_bet; dimensionless "probability"; makes sense for kap > 0
sig = sig0*P + 0.041/6.24*L*(1-P) # Eq. (7B) in 18_dev_bet
eta = eta0*L*exp(-eta1*L) # Eq. 9 in 18dev_bet
0.0104 + sig*Flux*(1-exp(-H)) + eta*(1-exp(-d/d_0))  #0.00071 + sig*6.24*d/L*(1-exp(-1024*d/L)) + eta*(1-exp(-10^3*d))#don't use
}
IDER_model = nlsLM(CA ~ IDER(d, L, Z.b, eta0, eta1, sig0, kap), data = modified_df, start = list(eta0 = 0.001, eta1 = 0.01, sig0 = 15, kap = 445),
weights = (1/(modified_df$error)^2))
calibrated_coef=coef(IDER_model)
summary(IDER_model, cor = T)
summary(new_Q_IDER_model_TEonly)
summary(new_Q_IDER_model)
summary(new_LQ_IDER_model)
L_TE <- resid(new_Q_IDER_model_TEonly) ** 2
L_NTE_Q <- resid(new_Q_IDER_model) ** 2
L_NTE_LQ <- resid(new_LQ_IDER_model) ** 2
L_IDER <- resid(IDER_model) ** 2
#Since all models are weighted least square regression, will weight our model with our weights to get the WRSS (weighted residual squared sum)
WRSS_TE = sum((1/modified_df$error^2)*L_TE)
WRSS_NTE_Q = sum((1/modified_df$error^2)*L_NTE_Q)
WRSS_NTE_LQ = sum((1/modified_df$error^2)*L_NTE_LQ)
WRSS_IDER = sum((1/modified_df$error^2)*L_IDER)
#functions for AIC and BIC calculation for Weighted Least Square regression
AIC_function = function(RSS, k = 4, n = length(modified_df[ , 1])) {
n + n*log(2*pi) + n*log(RSS/n) + 2*(k+1)
}
BIC_function = function(n = length(modified_df[, 1]), k = 4, RSS) {
n + n*log(2*pi) + n*log(RSS/n) + log(n)*(k+1)
}
TE_AIC = AIC_function(RSS = WRSS_TE, k = 2)
NTE_Q_AIC = AIC_function(RSS = WRSS_NTE_Q, k = 3)
NTE_LQ_AIC = AIC_function(RSS = WRSS_NTE_LQ)
IDER_AIC = AIC_function(RSS = WRSS_IDER)
TE_BIC = BIC_function(RSS = WRSS_TE, k = 2)
NTE_Q_BIC = BIC_function(RSS = WRSS_NTE_Q, k = 3)
NTE_LQ_BIC = BIC_function(RSS = WRSS_NTE_LQ)
IDER_BIC = BIC_function(RSS = WRSS_IDER)
information_critera_df = data.frame(Model = c("TE model","NTE_Q model", "NTE_LQ model", "IDER model"), AIC = c(TE_AIC, NTE_Q_AIC, NTE_LQ_AIC, IDER_AIC), BIC = c(TE_BIC, NTE_Q_BIC, NTE_LQ_BIC, IDER_BIC))
arrange(information_critera_df, AIC)
alpha0 <- as.numeric(coef(new_Q_IDER_model_TEonly)[1])
beta0 <- as.numeric(coef(new_Q_IDER_model_TEonly)[2])
TE_O <- function(d) TE_function(d, L = 75, alpha = alpha0, beta = beta0)
TE_Si <- function(d) TE_function(d, L = 100, alpha = alpha0, beta = beta0)
TE_Fe600 <- function(d) TE_function(d, L = 175, alpha = alpha0, beta = beta0)
ggplot(modified_df[modified_df$ion == "O", ], aes(x = d, y = CA)) + geom_point() + stat_function(fun = TE_O)
ggplot(modified_df[modified_df$ion == "Si", ], aes(x = d, y = CA)) + geom_point() + stat_function(fun = TE_Si)
ggplot(modified_df[modified_df$ion == "Fe600", ], aes(x = d, y = CA)) + geom_point() + stat_function(fun = TE_Fe600)
MIXTE_function = function(r, L, d = seq(0, 0.2, by = 0.001), alpha = alpha0, beta = beta0){
dE = function(yini, State, Pars){
n = length(L)
beta = beta0
with(as.list(c(State, Pars)), {
u = numeric(n)
for (i in 1:n){
u[i] = uniroot(function(d) {(alpha + beta *6.242*d/L[i])*(1 - exp(-30*6.242*d/L[i])) - I}, lower = 0, upper = 0.4, extendInt = "yes", tol = 10^-10)$root
}
dI = numeric(n)
H = numeric(n)
for(i in 1:n){
H[i] = 6.24*30*u[i]/L[i]
dI[i] = r[i]*(6.24/L[i] * exp(-H[i]) * (beta*(exp(H[i]) + H[i] - 1) + 30 * alpha)) #Partial derivative of TE function over d. This is always 0 when d = 0 though.
}
dI = sum(dI)
return(list(c(dI)))
})
}
pars = NULL; yini = c(I = 0); d = d
out = ode(yini,times = d, dE, pars, method = "radau")
return(out)
}
#Here is the TE function again for individual dose
TE_function = function(d, L, alpha, beta) {
Flux=6.242*d/L # Eq. (5a) in 18_dev_bet; a model-independent equation for particle flux
A = 30 #The area of the cell nucleus for lymphocytes
H=A*Flux
0 + (alpha + beta*Flux)*(1-exp(-H))
}
r = rep(1/3, 3); L = c(75, 100, 175); dose = seq(0,.4,by=0.001)
MX = MIXTE_function(r, L, d = dose)
plot(MX[,1],MX[,2],type='l',bty='l',col='red',ann='F',ylim=c(0,0.5))
for (ii in 1:length(L)){lines(dose,TE_function(dose,L[ii], alpha = alpha0, beta = beta0),col='green')}
#SEA
SEA=function(d){
TE_function(d = d/3,L[1], alpha = alpha0, beta = beta0) + TE_function(d/3,L[2],alpha = alpha0, beta = beta0)+TE_function(d/3,L[3],alpha = alpha0, beta = beta0)
}
lines(dose,SEA(dose),lty=2)
sig = vcov(new_Q_IDER_model_TEonly)
set.seed(10)
monte_carlo_parameters = rmvnorm(n = 500, mean = c(alpha = alpha0, beta = beta0), sigma = sig)
alpha0_MC = monte_carlo_parameters[, 1]
beta0_MC = monte_carlo_parameters[, 2]
CI_function_MIXTE = function(d, r, interval = 0.95, L, alphas = alpha0_MC, betas = beta0_MC) {
MIXTE_curve = list(length = 0)
for (i in 1:500) {
MIXTE_curve[[i]] = MIXTE_function(r, L, d = d, alpha = alphas[i], beta = betas[i])
}
info = vector(length = 0)
for (i in 1:500) {
info = c(info, MIXTE_curve[[i]][, 2][2])
}
info = sort(info)
lower_bound = quantile(info, (1-interval)/2)
upper_bound = quantile(info, 1 - (1-interval)/2)
CI = c(lower_bound, upper_bound)
return(CI)
}
out = MIXTE_function(r = rep(1/2, times = 2), L = c(100, 175), d = c(seq(0, 0.009, 0.001), seq(0.01, 0.5, by = 0.01)))
two_ion_MIXTE = data.frame(d = out[, 1], CA = out[, 2])
#two_ion_MIXTE = data.frame(d = out[, 1][seq(11,60, by = 5)], CA = out[, 2][seq(11,60, by = 5)]) I created this smaller sample to make sure my Monte-Carlo function works. Now that it does, I will use the full data. The full d includes d = 0 which gives errors in calculating the CI, so I took it out.)
d =(two_ion_MIXTE$d)[-1]
bounds <- data.frame(lower = vector(length = length(d)),upper = vector(length = length(d)))
#Then the 95% CI multivariate MC simulated ribbon
ninty_five_CI_lower = vector(length = 0)
ninty_five_CI_upper = vector(length = 0)
for (i in 1:length(d)) {
a = CI_function_MIXTE(d = c(0, d[i]), r = rep(1/2, times = 2),  L = c(100, 175))
bounds$lower[i-1] = a[1]
bounds$upper[i-1] = a[2]
ninty_five_CI_lower = c(ninty_five_CI_lower, a[1])
ninty_five_CI_upper = c(ninty_five_CI_upper, a[2])
}
two_ion_MIXTE$CI_lower = c(0, ninty_five_CI_lower) #Forcing d = 0 to have no CI (constant)
two_ion_MIXTE$CI_upper = c(0, ninty_five_CI_upper)
d <- c(0, d) #Adding 0 back
#Get the simple effect additivity MIXTE
two_ion_MIXTE$simpleeffect = TE_function(d = 0.5*d, L = 100, alpha = alpha0, beta = beta0) + TE_function(d = 0.5*d, L = 175, alpha = alpha0, beta = beta0)
#Get the individual TE_functionS
two_ion_MIXTE$silicon = TE_function(d = d, L = 100, alpha = alpha0, beta = beta0)
two_ion_MIXTE$ironsix = TE_function(d = d, L = 175, alpha = alpha0, beta = beta0)
CA <- two_ion_MIXTE$CA
simpleeffect <- two_ion_MIXTE$simpleeffect
silicon <- two_ion_MIXTE$silicon
ironsix <- two_ion_MIXTE$ironsix
plot(x = d * 100, y = CA * 100, type = "l", col = "red")
lines(x = d * 100, y = simpleeffect * 100, col = "black", lty = 2, lwd = 0.5) +
lines(x = d * 100, y = silicon* 100, col = "green")
lines(x = d * 100, y = ironsix* 100, col = "green")
lines(x= d*100 , y = two_ion_MIXTE$CI_upper * 100, lty = 'dashed', col = 'red')
lines(x= d*100 , y = two_ion_MIXTE$CI_lower * 100, lty = 'dashed', col = 'red')
polygon(c(d*100,rev(d*100)),c(two_ion_MIXTE$CI_lower * 100, rev(two_ion_MIXTE$CI_upper * 100)),col = rgb(1, 0, 0,0.5), border = NA)
out = MIXTE_function(r = rep(1/3, times = 3), L = c(75, 100, 175), d = c(seq(0, 0.009, 0.001), seq(0.01, 0.5, by = 0.01)))
three_ion_MIXTE = data.frame(d = out[, 1], CA = out[, 2])
d <- (three_ion_MIXTE$d)[-1] #Taking out 0 to avoid errors in calculating CI's.
bounds <- data.frame(lower = vector(length = length(d)),upper = vector(length = length(d)))
#Then the 95% CI multivariate MC simulated ribbon
ninty_five_CI_lower = vector(length = 0)
ninty_five_CI_upper = vector(length = 0)
for (i in 1:length(d)) {
a = CI_function_MIXTE(d = c(0, d[i]), r = rep(1/3, times = 3),  L = c(75, 100, 175))
bounds$lower[i-1] = a[1]
bounds$upper[i-1] = a[2]
ninty_five_CI_lower = c(ninty_five_CI_lower, a[1])
ninty_five_CI_upper = c(ninty_five_CI_upper, a[2])
}
three_ion_MIXTE$CI_lower = c(0, ninty_five_CI_lower)
three_ion_MIXTE$CI_upper = c(0, ninty_five_CI_upper)
d <- c(0, d)
#Get the individual TE_functionS
three_ion_MIXTE$oxygen = TE_function(d = d, L = 75, alpha = alpha0, beta = beta0)
three_ion_MIXTE$silicon = TE_function(d = d, L = 100, alpha = alpha0, beta = beta0)
three_ion_MIXTE$ironsix = TE_function(d = d, L = 175, alpha = alpha0, beta = beta0)
#Get the simple effect additivity MIXTE
three_ion_MIXTE$simpleeffect = TE_function(d = d/3, L = 75, alpha = alpha0, beta = beta0) + TE_function(d = d/3, L = 100, alpha = alpha0, beta = beta0) + TE_function(d = d/3, L = 175, alpha = alpha0, beta = beta0)
plot(x = d * 100, y = three_ion_MIXTE$CA * 100, type = "l", col = "red")
lines(x = d * 100, y = three_ion_MIXTE$simpleeffect * 100, col = "black", lty = 2, lwd = 0.5) +
lines(x = d * 100, y = three_ion_MIXTE$oxygen* 100, col = "green")
lines(x = d * 100, y = three_ion_MIXTE$silicon* 100, col = "green")
lines(x = d * 100, y = three_ion_MIXTE$ironsix* 100, col = "green")
lines(x= d*100 , y = three_ion_MIXTE$CI_upper * 100, lty = 'dashed', col = 'red')
lines(x= d*100 , y = three_ion_MIXTE$CI_lower * 100, lty = 'dashed', col = 'red')
polygon(c(d*100,rev(d*100)),c(three_ion_MIXTE$CI_lower * 100, rev(three_ion_MIXTE$CI_upper * 100)),col = rgb(1, 0, 0,0.5), border = NA)
