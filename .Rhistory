NTE1_BIC = BIC_function(RSS = WRSS_NTE1)
NTE2_BIC = BIC_function(RSS = WRSS_NTE2)
IDER_BIC = BIC_function(RSS = WRSS_IDER)
information_critera_df = data.frame(AIC = c(NTE1_AIC, NTE2_AIC, IDER_AIC), BIC = c(NTE1_BIC, NTE2_BIC, IDER_BIC), row.names = c("NTE1 model", "NTE2 model", "IDER model"))
information_critera_df ## RKS runs well up to here. Lots of checks made 8/12/2017
# #Baseline no-synergy/no-antagonism MIXDER  based on any input
MIXDER_function = function(r, L, Z.b, d = seq(0, 0.2, by = 0.001), eta0 = eta00, eta1 = eta10, sig0 = sig00 ,kap = kap0) {
dE=function(yini,State,Pars){
eta0 = eta0; eta1 = eta1; sig0 = sig0; kap = kap
with(as.list(c(State, Pars)), {
P = vector(length = length(L))
sig = vector(length = length(L))
etaa = vector(length = length(L))
u = vector(length = length(L))
for (i in 1:length(L)) {
P[i] = (1-exp(-Z.b[i]/kap))^2
sig[i] = sig0*P[i] + 0.041/6.24*L[i]*(1-P[i])
etaa[i] = eta0*L[i]*exp(-eta1*L[i])
u[i] = uniroot(function(d) sig[i]*6.24*d/L[i]*(1-exp(-1024*d/L[i])) + etaa[i]*(1-exp(-10^5*d)) - I, lower = 0, upper = 1, extendInt = "yes", tol = 10^-10)$root
}
print(u)
dI = vector(length = length(L))
for (i in 1:length(L)) {
dI[i] = r[i]*(sig[i]*6.24/L[i]*exp(-1024*u[i]/L[i])*(exp(1024*u[i]/L[i]) + 1024*u[i]/L[i] - 1) + etaa[i]*10^5*exp(-10^5*u[i]))
}
dI = sum(dI)
return(list(c(dI)))
})
}
pars = NULL; yini = c(I= 0); d = d
out = ode(yini,times = d, dE, pars, method = "radau")
return(out)
}
r=rep(1/6,6);L = c(75, 100, 125, 175, 195, 240); Z.b = c(595, 690, 770, 1075, 1245, 1585);dose=c(0.01, 0.02, 0.03)
MX=MIXDER_function(r,L,Z.b,d=dose)#for this mixture can't go much above 0.6#
r=rep(1/6,6);L = c(75, 100, 125, 175, 195, 240); Z.b = c(595, 690, 770, 1075, 1245, 1585);dose=c(0.01, 0.02, 0.03)
MX=MIXDER_function(r,L,Z.b,d=dose)#for this mixture can't go much above 0.6#
plot(MX[,1],MX[,2],type='l',bty='l',col='red',ann='F',ylim=c(0,.10))
for (ii in 1:length(L)){lines(dose,IDER (dose,L[ii],Z.b[ii]),col='green')}
XX <- coef(IDER_model)
eta00 <- as.numeric(XX[1])
eta10 <- as.numeric(XX[2])
sig00 <- as.numeric(XX[3])
kap0 <- as.numeric(XX[4])
MX=MIXDER_function(r,L,Z.b,d=dose)#for this mixture can't go much above 0.6#
plot(MX[,1],MX[,2],type='l',bty='l',col='red',ann='F',ylim=c(0,.10))
for (ii in 1:length(L)){lines(dose,IDER (dose,L[ii],Z.b[ii]),col='green')}
library(deSolve) # package for solving differential equations
library(minpack.lm) # package for non-linear regression #rks to laz: I think we probably can just use nls() in stats, not nlsLM from linpack. Please check in R documentation if there is any functional difference at all
library(mvtnorm) # package for calculating confidence intervals by Monte Carlo simulation based on variance-covariance matrices #rks to laz: I added to comment. Please check that my addition is OK.
rm(list=ls())
#Create dataframes that store the fibroblast WGE simple CA data used in 16Cacao
Oxygen = data.frame(d = c(0, .0125, .02, .025, .05, .075, .1, .2, .4),CA = c(.24, 1.66, 2.43, 2.37, 1.16, 2.85, 2.58, 6.94, 6.91))
# Some GCR components are high-speed Oxygen nuclei that are almost fully ionized. d=dose; CA are per hundred cells.
Si = data.frame(d = c(0, .02, .04, .06, .08, .1, .12, .2, .4, .8, 1.2), CA = c(.11, 1.26, 1.14, 1.58, 1.22, 1.89, 3.47, 4.6, 9.79, 27.01, 38.84))
Fe600 = data.frame(d = c(0, .01, .02, .04, .06, .08, .1, .12, .2, .4, .8), CA = c(.13, .76, .99, 1.2, 1.74, 1.28, 1.2, 1.7, 3.02, 5.52, 12.42))
#600 refers to the energy in MeV per atomic mass unit in this Iron beam
Fe450 = data.frame(d = c(0, .02, .04, .06, .08, .1, .2, .4), CA = c(0, .86, .6, .8, 1.22, 2.02, 2.3, 4.77))
Fe300 = data.frame(d = c(0, .005, .01,  0.02, .04, .07, .1, .2, .4, .8), CA = c(0.41, 1.23, 1.47, 1.22, .97, 1.46, 1.21, 4.38, 6.22, 13.6))
Ti = data.frame(d = c(0,  0.02, .04, .06, .08, .1, .15, .3, .6), CA = c(0, 1.99, 1.88, 1.44, 2.67, 2.57, 2.50, 5.64, 11.19))
param = data.frame(ion = c("O", "Si", "Ti", "Fe600", "Fe450", "Fe300"),
Z = c(8, 14, 22, 26, 26, 26), L = c(75, 100, 125, 175, 195, 240), #Z=atomic charge; L=LET
Z.b = c(595, 690, 770, 1075, 1245, 1585))#Z^2/beta*^2
#putting it in one big data frame. #rks: the data frame incorporates a correction to Fe600 at dose 0.06, near line 34
big_df = rbind(Oxygen, Si, Ti, Fe600, Fe450, Fe300)
big_df$Z = rep(param$Z, times = c(9, 11, 9, 11, 8, 10))
big_df$Z.b = rep(param$Z.b, times = c(9, 11, 9, 11, 8, 10))
big_df$L = rep(param$L, times = c(9, 11, 9, 11, 8, 10))
big_df$error = c(0.24, 0.63, 0.77, 0.75, 0.52, 0.82, 0.78, 1.31, 1.59, 0.12, 0.05, 0.07, 0.56, 0.18, 0.60, 1.23, 1.60, 1.55, 4.27, 7.21, 0, 0.70, 0.66, 0.59, 0.80, 0.78, 0.48, 1.15, 2.39, 0.16, 0.38, 0.24, 0.21, 0.43, 0.37, 0.54, 0.17, 0.55, 1.75, 2.59, 0, 0.43, 0.34, 0.40, 0.50, 0.64, 0.73, 1.09, 0.29, 0.55, 0.60, 0.55, 0.49, 0.60, 0.54, 1.03, 1.22, 3.62) #error bars for the CA measurements
big_df$ion = rep(param$ion, times = c(9, 11, 9, 11, 8, 10))
#Next modify the data frame to get rid of the zero dose points. Background CA frequency was determined seperately.
modified_df = big_df[big_df$d != 0, ]
modified_df$CA = modified_df$CA*0.01 # Use CA per 100 cells
modified_df$error = modified_df$error*0.01
big_df$CA = big_df$CA * 0.01
big_df$error = big_df$error * 0.01
big_df$errorbar_lower = big_df$CA - big_df$error
big_df$errorbar_upper = big_df$CA + big_df$error
#NTE1 and NTE2 models in 16Cacao using their parameters. NTE is used in 16Cacao to signify that non-targeted effects are included in the model; Conventional targeted effects (TE) are included in all models.
#NTE1 function
NTE1_function = function(d, L, Z.b, eta0 = 0.00011, eta1 = 0.007, sig0 = 6.12, kap = 796) {
0.0017 + eta0*L*exp(-eta1*L)*(d != 0) +
(6.242*(d/L))*(sig0*(1-exp(-Z.b/kap))^2 + 0.041/6.24*L*(1 - (1-exp(-Z.b/kap))^2))
}
#NTE2 function
NTE2_function = function(d, L, Z.b, eta0 = 0.00047, eta1 = 0.011, sig0 = 6.75, kap = 590) {
0.0017 + eta0*L*exp(-eta1*L)*exp(-(1012*(d/L)))*(d != 0) +
(6.242*(d/L))*(1-exp(-(1012*(d/L))))*
(sig0*(1-exp(-Z.b/kap))^2 + 0.041/6.24*L*(1 - (1-exp(-Z.b/kap))^2))
}
#Our IDERs (Individual Dose Effect Relations). Applicable to the 1-ion components of a mixed simulated GCR beam
#Modifying NTE1 and NTE2 by insisting they be twice continuously differentiable and monotonic increasing. Double check NTE1, NTE2, Our model
IDER = function(d, L, Z.b, eta00, eta10, sig00, kap0) {
P = (1-exp(-Z.b/kap0))^2
sig = sig00*P + 0.041/6.24*L*(1-P) # 0.041 +- 0.0051 comes from 16Cacao
eta = eta00*L*exp(-eta10*L)
0.00071 + sig*6.24*d/L*(1-exp(-1024*d/L)) + eta*(1-exp(-10^5*d))  #0.00071 + sig*6.24*d/L*(1-exp(-1024*d/L)) + eta*(1-exp(-10^3*d))#don't use
}
#nls (non-linear least square) method to get the parameters needed (4 parameter estimation) #rks to laz: see note under issues
IDER_model = nlsLM(CA ~ IDER(d, L, Z.b, eta00, eta10, sig00, kap0), data = modified_df, start = list(eta00 = 0.001, eta10 = 0.01, sig00 = 5, kap0 = 500),
weights = (1/(modified_df$error)^2))
coef(IDER_model)
#e.g. eta0 = 1.484687e-04, eta1 = 3.513927e-03, sig0 = 4.149660e+00, kap = 4.688287e+02
vcov(IDER_model)# variance-covariance matrix, needed later for analyzing 95% confidence limits in baseline no-synergy/no-antagonism MIXDER (Mixture dose effect relation)
summary(IDER_model, cor = TRUE) #model parameters and their correlation matrix
XX <- coef(IDER_model)
eta00 <- as.numeric(XX[1])
eta10 <- as.numeric(XX[2])
sig00 <- as.numeric(XX[3])
kap0 <- as.numeric(XX[4])
#R function to give Information criteria (AIC and BIC) #rks to laz: R has AIC functions. Please check that they give the same ordering (not necessarily the same values) as the ones constructed below by Dae or you.
#L_function gives the residuals squared
L_function = function(func, eta0, eta1, sig0, kap) {
a = vector(length = 0)
for (i in 1:length(modified_df[, 1])) {
a = c(a, modified_df$CA[i] - func(d = modified_df$d[i], L = modified_df$L[i], Z.b = modified_df$Z.b[i], eta0 = eta0, eta1 = eta1, sig0 = sig0, kap = kap))
}
return(a^2)
}
L_NTE1 = L_function(NTE1_function, eta0 = 0.00011, eta1 = 0.007, sig0 = 6.12, kap = 796)
L_NTE2 = L_function(NTE2_function, eta0 = 0.00047, eta1 = 0.011, sig0 = 6.75, kap = 590)
L_IDER = L_function(IDER, eta0 = eta00, eta1 = eta10, sig0 = sig00, kap = kap0)
#Since all models are weighted least square regression, will weight our model with our weights to get the WRSS (weighted residual squared sum)
WRSS_NTE1 = sum((1/modified_df$error^2)*L_NTE1)
WRSS_NTE2 = sum((1/modified_df$error^2)*L_NTE2)
WRSS_IDER = sum((1/modified_df$error^2)*L_IDER)
#functions for AIC and BIC calculation for Weighted Least Square regression
AIC_function = function(RSS, k = 4, n = length(modified_df[ , 1])) {
n + n*log(2*pi) + n*log(RSS/n) + 2*(k+1)
}
BIC_function = function(n = length(modified_df[, 1]), k = 4, RSS) {
n + n*log(2*pi) + n*log(RSS/n) + log(n)*(k+1)
}
NTE1_AIC = AIC_function(RSS = WRSS_NTE1)
NTE2_AIC = AIC_function(RSS = WRSS_NTE2)
IDER_AIC = AIC_function(RSS = WRSS_IDER)
NTE1_BIC = BIC_function(RSS = WRSS_NTE1)
NTE2_BIC = BIC_function(RSS = WRSS_NTE2)
IDER_BIC = BIC_function(RSS = WRSS_IDER)
information_critera_df = data.frame(AIC = c(NTE1_AIC, NTE2_AIC, IDER_AIC), BIC = c(NTE1_BIC, NTE2_BIC, IDER_BIC), row.names = c("NTE1 model", "NTE2 model", "IDER model"))
information_critera_df ## RKS runs well up to here. Lots of checks made 8/12/2017
# #Baseline no-synergy/no-antagonism MIXDER  based on any input
MIXDER_function = function(r, L, Z.b, d = seq(0, 0.2, by = 0.001), eta0 = eta00, eta1 = eta10, sig0 = sig00 ,kap = kap0) {
dE=function(yini,State,Pars){
eta0 = eta0; eta1 = eta1; sig0 = sig0; kap = kap
with(as.list(c(State, Pars)), {
P = vector(length = length(L))
sig = vector(length = length(L))
etaa = vector(length = length(L))
u = vector(length = length(L))
for (i in 1:length(L)) {
P[i] = (1-exp(-Z.b[i]/kap))^2
sig[i] = sig0*P[i] + 0.041/6.24*L[i]*(1-P[i])
etaa[i] = eta0*L[i]*exp(-eta1*L[i])
u[i] = uniroot(function(d) sig[i]*6.24*d/L[i]*(1-exp(-1024*d/L[i])) + etaa[i]*(1-exp(-10^5*d)) - I, lower = 0, upper = 1, extendInt = "yes", tol = 10^-10)$root
}
print(u)
dI = vector(length = length(L))
for (i in 1:length(L)) {
dI[i] = r[i]*(sig[i]*6.24/L[i]*exp(-1024*u[i]/L[i])*(exp(1024*u[i]/L[i]) + 1024*u[i]/L[i] - 1) + etaa[i]*10^5*exp(-10^5*u[i]))
}
dI = sum(dI)
return(list(c(dI)))
})
}
pars = NULL; yini = c(I= 0); d = d
out = ode(yini,times = d, dE, pars, method = "radau")
return(out)
}
#Graphs for NTE1 and our IDER models: 12_ion figure
#When creating any sort of MIXDER figures we use this IDER now without the background effect then add the background effect at the end.
IDER = function(d, L, Z.b, eta0 = eta00, eta1 = eta10, sig0 = sig00, kap = kap0) {
P = (1-exp(-Z.b/kap0))^2
sig = sig0*P + 0.041/6.24*L*(1-P)
eta = eta0*L*exp(-eta1*L)
sig*6.24*d/L*(1-exp(-1024*d/L)) + eta*(1-exp(-10^5*d))#sig*6.24*d/L*(1-exp(-1024*d/L)) + eta*(1-exp(-.5*10^3*d))#don't use
}
r=rep(1/6,6);L = c(75, 100, 125, 175, 195, 240); Z.b = c(595, 690, 770, 1075, 1245, 1585);dose=c(0.01, 0.02, 0.03)
MX=MIXDER_function(r,L,Z.b,d=dose)#for this mixture can't go much above 0.6#
plot(MX[,1],MX[,2],type='l',bty='l',col='red',ann='F',ylim=c(0,.10))
for (ii in 1:length(L)){lines(dose,IDER (dose,L[ii],Z.b[ii]),col='green')}
#SEA
SEA=function(d){
IDER(d/6,L[1],Z.b[1])+IDER(d/6,L[2],Z.b[2])+IDER(d/6,L[3],Z.b[3])+IDER(d/6,L[4],Z.b[4])+IDER(d/6,L[5],Z.b[5])+IDER(d/6,L[6],Z.b[6])
}
lines(dose,SEA(dose),lty=2)
library(deSolve) # package for solving differential equations
library(minpack.lm) # package for non-linear regression #rks to laz: I think we probably can just use nls() in stats, not nlsLM from linpack. Please check in R documentation if there is any functional difference at all
library(mvtnorm) # package for calculating confidence intervals by Monte Carlo simulation based on variance-covariance matrices #rks to laz: I added to comment. Please check that my addition is OK.
rm(list=ls())
#Create dataframes that store the fibroblast WGE simple CA data used in 16Cacao
Oxygen = data.frame(d = c(0, .0125, .02, .025, .05, .075, .1, .2, .4),CA = c(.24, 1.66, 2.43, 2.37, 1.16, 2.85, 2.58, 6.94, 6.91))
# Some GCR components are high-speed Oxygen nuclei that are almost fully ionized. d=dose; CA are per hundred cells.
Si = data.frame(d = c(0, .02, .04, .06, .08, .1, .12, .2, .4, .8, 1.2), CA = c(.11, 1.26, 1.14, 1.58, 1.22, 1.89, 3.47, 4.6, 9.79, 27.01, 38.84))
Fe600 = data.frame(d = c(0, .01, .02, .04, .06, .08, .1, .12, .2, .4, .8), CA = c(.13, .76, .99, 1.2, 1.74, 1.28, 1.2, 1.7, 3.02, 5.52, 12.42))
#600 refers to the energy in MeV per atomic mass unit in this Iron beam
Fe450 = data.frame(d = c(0, .02, .04, .06, .08, .1, .2, .4), CA = c(0, .86, .6, .8, 1.22, 2.02, 2.3, 4.77))
Fe300 = data.frame(d = c(0, .005, .01,  0.02, .04, .07, .1, .2, .4, .8), CA = c(0.41, 1.23, 1.47, 1.22, .97, 1.46, 1.21, 4.38, 6.22, 13.6))
Ti = data.frame(d = c(0,  0.02, .04, .06, .08, .1, .15, .3, .6), CA = c(0, 1.99, 1.88, 1.44, 2.67, 2.57, 2.50, 5.64, 11.19))
param = data.frame(ion = c("O", "Si", "Ti", "Fe600", "Fe450", "Fe300"),
Z = c(8, 14, 22, 26, 26, 26), L = c(75, 100, 125, 175, 195, 240), #Z=atomic charge; L=LET
Z.b = c(595, 690, 770, 1075, 1245, 1585))#Z^2/beta*^2
#putting it in one big data frame. #rks: the data frame incorporates a correction to Fe600 at dose 0.06, near line 34
big_df = rbind(Oxygen, Si, Ti, Fe600, Fe450, Fe300)
big_df$Z = rep(param$Z, times = c(9, 11, 9, 11, 8, 10))
big_df$Z.b = rep(param$Z.b, times = c(9, 11, 9, 11, 8, 10))
big_df$L = rep(param$L, times = c(9, 11, 9, 11, 8, 10))
big_df$error = c(0.24, 0.63, 0.77, 0.75, 0.52, 0.82, 0.78, 1.31, 1.59, 0.12, 0.05, 0.07, 0.56, 0.18, 0.60, 1.23, 1.60, 1.55, 4.27, 7.21, 0, 0.70, 0.66, 0.59, 0.80, 0.78, 0.48, 1.15, 2.39, 0.16, 0.38, 0.24, 0.21, 0.43, 0.37, 0.54, 0.17, 0.55, 1.75, 2.59, 0, 0.43, 0.34, 0.40, 0.50, 0.64, 0.73, 1.09, 0.29, 0.55, 0.60, 0.55, 0.49, 0.60, 0.54, 1.03, 1.22, 3.62) #error bars for the CA measurements
big_df$ion = rep(param$ion, times = c(9, 11, 9, 11, 8, 10))
#Next modify the data frame to get rid of the zero dose points. Background CA frequency was determined seperately.
modified_df = big_df[big_df$d != 0, ]
modified_df$CA = modified_df$CA*0.01 # Use CA per 100 cells
modified_df$error = modified_df$error*0.01
big_df$CA = big_df$CA * 0.01
big_df$error = big_df$error * 0.01
big_df$errorbar_lower = big_df$CA - big_df$error
big_df$errorbar_upper = big_df$CA + big_df$error
#NTE1 and NTE2 models in 16Cacao using their parameters. NTE is used in 16Cacao to signify that non-targeted effects are included in the model; Conventional targeted effects (TE) are included in all models.
#NTE1 function
NTE1_function = function(d, L, Z.b, eta0 = 0.00011, eta1 = 0.007, sig0 = 6.12, kap = 796) {
0.0017 + eta0*L*exp(-eta1*L)*(d != 0) +
(6.242*(d/L))*(sig0*(1-exp(-Z.b/kap))^2 + 0.041/6.24*L*(1 - (1-exp(-Z.b/kap))^2))
}
#NTE2 function
NTE2_function = function(d, L, Z.b, eta0 = 0.00047, eta1 = 0.011, sig0 = 6.75, kap = 590) {
0.0017 + eta0*L*exp(-eta1*L)*exp(-(1012*(d/L)))*(d != 0) +
(6.242*(d/L))*(1-exp(-(1012*(d/L))))*
(sig0*(1-exp(-Z.b/kap))^2 + 0.041/6.24*L*(1 - (1-exp(-Z.b/kap))^2))
}
#Our IDERs (Individual Dose Effect Relations). Applicable to the 1-ion components of a mixed simulated GCR beam
#Modifying NTE1 and NTE2 by insisting they be twice continuously differentiable and monotonic increasing. Double check NTE1, NTE2, Our model
IDER = function(d, L, Z.b, eta00, eta10, sig00, kap0) {
P = (1-exp(-Z.b/kap0))^2
sig = sig00*P + 0.041/6.24*L*(1-P) # 0.041 +- 0.0051 comes from 16Cacao
eta = eta00*L*exp(-eta10*L)
0.00071 + sig*6.24*d/L*(1-exp(-1024*d/L)) + eta*(1-exp(-10^5*d))  #0.00071 + sig*6.24*d/L*(1-exp(-1024*d/L)) + eta*(1-exp(-10^3*d))#don't use
}
#nls (non-linear least square) method to get the parameters needed (4 parameter estimation) #rks to laz: see note under issues
IDER_model = nlsLM(CA ~ IDER(d, L, Z.b, eta00, eta10, sig00, kap0), data = modified_df, start = list(eta00 = 0.001, eta10 = 0.01, sig00 = 5, kap0 = 500),
weights = (1/(modified_df$error)^2))
coef(IDER_model)
#e.g. eta0 = 1.484687e-04, eta1 = 3.513927e-03, sig0 = 4.149660e+00, kap = 4.688287e+02
vcov(IDER_model)# variance-covariance matrix, needed later for analyzing 95% confidence limits in baseline no-synergy/no-antagonism MIXDER (Mixture dose effect relation)
summary(IDER_model, cor = TRUE) #model parameters and their correlation matrix
XX <- coef(IDER_model)
eta00 <- as.numeric(XX[1])
eta10 <- as.numeric(XX[2])
sig00 <- as.numeric(XX[3])
kap0 <- as.numeric(XX[4])
#R function to give Information criteria (AIC and BIC) #rks to laz: R has AIC functions. Please check that they give the same ordering (not necessarily the same values) as the ones constructed below by Dae or you.
#L_function gives the residuals squared
L_function = function(func, eta0, eta1, sig0, kap) {
a = vector(length = 0)
for (i in 1:length(modified_df[, 1])) {
a = c(a, modified_df$CA[i] - func(d = modified_df$d[i], L = modified_df$L[i], Z.b = modified_df$Z.b[i], eta0 = eta0, eta1 = eta1, sig0 = sig0, kap = kap))
}
return(a^2)
}
L_NTE1 = L_function(NTE1_function, eta0 = 0.00011, eta1 = 0.007, sig0 = 6.12, kap = 796)
L_NTE2 = L_function(NTE2_function, eta0 = 0.00047, eta1 = 0.011, sig0 = 6.75, kap = 590)
L_IDER = L_function(IDER, eta0 = eta00, eta1 = eta10, sig0 = sig00, kap = kap0)
#Since all models are weighted least square regression, will weight our model with our weights to get the WRSS (weighted residual squared sum)
WRSS_NTE1 = sum((1/modified_df$error^2)*L_NTE1)
WRSS_NTE2 = sum((1/modified_df$error^2)*L_NTE2)
WRSS_IDER = sum((1/modified_df$error^2)*L_IDER)
#functions for AIC and BIC calculation for Weighted Least Square regression
AIC_function = function(RSS, k = 4, n = length(modified_df[ , 1])) {
n + n*log(2*pi) + n*log(RSS/n) + 2*(k+1)
}
BIC_function = function(n = length(modified_df[, 1]), k = 4, RSS) {
n + n*log(2*pi) + n*log(RSS/n) + log(n)*(k+1)
}
NTE1_AIC = AIC_function(RSS = WRSS_NTE1)
NTE2_AIC = AIC_function(RSS = WRSS_NTE2)
IDER_AIC = AIC_function(RSS = WRSS_IDER)
NTE1_BIC = BIC_function(RSS = WRSS_NTE1)
NTE2_BIC = BIC_function(RSS = WRSS_NTE2)
IDER_BIC = BIC_function(RSS = WRSS_IDER)
information_critera_df = data.frame(AIC = c(NTE1_AIC, NTE2_AIC, IDER_AIC), BIC = c(NTE1_BIC, NTE2_BIC, IDER_BIC), row.names = c("NTE1 model", "NTE2 model", "IDER model"))
information_critera_df ## RKS runs well up to here. Lots of checks made 8/12/2017
# #Baseline no-synergy/no-antagonism MIXDER  based on any input
MIXDER_function = function(r, L, Z.b, d = seq(0, 0.2, by = 0.001), eta0 = eta00, eta1 = eta10, sig0 = sig00 ,kap = kap0) {
dE=function(yini,State,Pars){
eta0 = eta0; eta1 = eta1; sig0 = sig0; kap = kap
with(as.list(c(State, Pars)), {
P = vector(length = length(L))
sig = vector(length = length(L))
etaa = vector(length = length(L))
u = vector(length = length(L))
for (i in 1:length(L)) {
P[i] = (1-exp(-Z.b[i]/kap))^2
sig[i] = sig0*P[i] + 0.041/6.24*L[i]*(1-P[i])
etaa[i] = eta0*L[i]*exp(-eta1*L[i])
u[i] = uniroot(function(d) sig[i]*6.24*d/L[i]*(1-exp(-1024*d/L[i])) + etaa[i]*(1-exp(-10^5*d)) - I, lower = 0, upper = 1, extendInt = "yes", tol = 10^-10)$root
}
dI = vector(length = length(L))
for (i in 1:length(L)) {
dI[i] = r[i]*(sig[i]*6.24/L[i]*exp(-1024*u[i]/L[i])*(exp(1024*u[i]/L[i]) + 1024*u[i]/L[i] - 1) + etaa[i]*10^5*exp(-10^5*u[i]))
}
dI = sum(dI)
return(list(c(dI)))
})
}
pars = NULL; yini = c(I= 0); d = d
out = ode(yini,times = d, dE, pars, method = "radau")
return(out)
}
#Graphs for NTE1 and our IDER models: 12_ion figure
#When creating any sort of MIXDER figures we use this IDER now without the background effect then add the background effect at the end.
IDER = function(d, L, Z.b, eta0 = eta00, eta1 = eta10, sig0 = sig00, kap = kap0) {
P = (1-exp(-Z.b/kap0))^2
sig = sig0*P + 0.041/6.24*L*(1-P)
eta = eta0*L*exp(-eta1*L)
sig*6.24*d/L*(1-exp(-1024*d/L)) + eta*(1-exp(-10^5*d))#sig*6.24*d/L*(1-exp(-1024*d/L)) + eta*(1-exp(-.5*10^3*d))#don't use
}
r=rep(1/6,6);L = c(75, 100, 125, 175, 195, 240); Z.b = c(595, 690, 770, 1075, 1245, 1585);dose=seq(0,.4,by=0.001)
MX=MIXDER_function(r,L,Z.b,d=dose)#for this mixture can't go much above 0.6#
plot(MX[,1],MX[,2],type='l',bty='l',col='red',ann='F',ylim=c(0,.10))
for (ii in 1:length(L)){lines(dose,IDER (dose,L[ii],Z.b[ii]),col='green')}
#SEA
SEA=function(d){
IDER(d/6,L[1],Z.b[1])+IDER(d/6,L[2],Z.b[2])+IDER(d/6,L[3],Z.b[3])+IDER(d/6,L[4],Z.b[4])+IDER(d/6,L[5],Z.b[5])+IDER(d/6,L[6],Z.b[6])
}
lines(dose,SEA(dose),lty=2)
MIXTE_function = function(r, L, Z.b, d = seq(0, 0.2, by = 0.001), beta = beta){
dE = function(yini, State, Pars){
n = length(L)
beta = beta0
with(as.list(c(State, Pars)), {
u = numeric(n)
for (i in 1:n){
u[i] = uniroot(function(d) {beta *6.242*d/L[i]*(1 - exp(-30*6.242*d/L[i])) - I}, lower = 0, upper = 0.4, extendInt = "yes", tol = 10^-10)$root
}
dI = numeric(n)
H = numeric(n)
for(i in 1:n){
H[i] = 6.24*30*u[i]/L[i]
dI[i] = r[i]*(beta * 6.24/L[i] * exp(-H[i]) * (exp(H[i]) + H[i] - 1)) #Partial derivative of TE function over d
}
dI = sum(dI)
return(list(c(dI)))
})
}
pars = NULL; yini = c(I = 0); d = d
out = ode(yini,times = d, dE, pars, method = "radau")
return(out)
}
knitr::opts_chunk$set(echo = TRUE)
library(deSolve) # package for solving differential equations
library(minpack.lm) # package for non-linear regression #rks to laz: I think we probably can just use nls() in stats, not nlsLM from linpack. Please check in R documentation if there is any functional difference at all
library(mvtnorm) #package for calculating confidence intervals by Monte Carlo simulation based on variance-covariance matrices #rks to laz: I added to comment.Please check that my addition is OK.
library(dplyr)
rm(list=ls())
#Create dataframes that store the fibroblast WGE simple CA data used in 16Cacao
#L and Z.b are rounded to the nearest 5.
Oxygen = data.frame(d = c(0, .0125, .025, .05, .075, .1, .2, .3, .4, .8),CA = c(.72, .96, 2.83, 4.7, 4.01, 8.41, 16.8, 40, 42.8, 94.4), ion = "O", Z = 8, L = 75, Z.b = 595)# Some GCR components are high-speed Oxygen nuclei that are almost fully ionized. d=dose; CA are per hundred cells. Z=atomic charge; L=LET; Z.b = Z^2/beta*^2
Si = data.frame(d = c(0, .02, .04, .06, .08, .1, .12, .15, .2, .3, .4, .6, .8, 1, 1.2, 1.5), CA = c(1.08, 2.04, 3.83, 4.57, 5.96, 4.78, 5.48, 13.88, 13.14, 27.0, 25.9, 59.5, 36.8, 81.8, 117.8, 123.2), ion = "Si", Z = 14, L = 100, Z.b = 690)
Fe600 = data.frame(d = c(0, 0.005, .01, .02, .04, .07, .1, .15, .2, .3, .4, .6, 1, 1.5), CA = c(1.01, 2.05, 2.33, 3.9, 3.51, 3.27, 5.71, 10.7, 9.14, 12.2, 21, 24.9, 43.6, 93.9), ion = "Fe600", Z = 26, L = 175, Z.b = 1075) #600 refers to the energy in MeV per atomic mass unit in this Iron beam
big_df = rbind(Oxygen, Si, Fe600)
big_df$error = c(.42, .48, 1.16, 1.36, 0.94, 2.54, 2.65, 5.9, 6.85, 13.6, .21, .34, .70, .95, .68, 1.07, 1.04, 2.38, 1.72, 4.77, 0.87, 9.18, 2.75, 9.85, 17, 13.2, 0.43, 0.48, 0.67, 0.8, 0.73, 0.75, 1.72, 1.95, 2.89, 2.34, 4.37, 5.08, 8.25, 18.8) #error bars for the CA measurementsx
#Next modify the data frame to get rid of the zero dose points. Background CA frequency was determined seperately.
modified_df = big_df[big_df$d != 0, ]
modified_df$CA = modified_df$CA*0.01 #Change it into per cell from per 100 cells
modified_df$error = modified_df$error*0.01
big_df$CA = big_df$CA * 0.01
big_df$error = big_df$error * 0.01
big_df$errorbar_lower = big_df$CA - big_df$error
big_df$errorbar_upper = big_df$CA + big_df$error
eta_1s <- c(0.97, -0.5, -0.75)/100
eta_2s <- c(3.11, 2.94, 1.47)/100
L <- c(175, 100, 75)
#eta <- c(0.46, 0.26, 0.75, 0.07, 1.21)/100
#eta <- c(1.07, 0.79, 1.18, 0.97, 2.32)/100
#L <- c(175, 195, 220, 100, 75)
eta_nte1 <- data.frame(eta = eta_1s, L)
eta_nte2 <- data.frame(eta = eta_2s, L)
eta_function <- function(L, eta0, eta1){
eta0 * L * exp(-eta1 * L)
}
NTE1_etafit <- nlsLM(eta ~ eta_function(L, eta0, eta1), data = eta_nte1, start = list(eta0 = 0.001, eta1 = 0.01))
NTE2_etafit <- nlsLM(eta ~ eta_function(L, eta0, eta1), data = eta_nte2, start = list(eta0 = 0.001, eta1 = 0.01))
summary(NTE1_etafit)
summary(NTE2_etafit)
d_0=10^-5 # nominal dose where NTE are saturating, so that for d>>d_0 further increases are due to TE
TE_function = function(d, L, beta) {
#rks to laz and spw. This is proposed new TE-only model for lymphocytes
Flux=6.242*d/L # Eq. (5a) in 18_dev_bet; a model-independent equation for particle flux
A = 30 #The area of the cell nucleus for lymphocytes
H=A*Flux
0 + beta*Flux*(1-exp(-H))
}
new_Q_IDER_model_TEonly = nlsLM(CA ~ TE_function(d, L,beta), data = modified_df, start = list(beta=3),
weights = (1/(modified_df$error)^2))
NTE_Q_function = function(d, L, eta0, eta1, beta) {
Flux=6.242*d/L # rks to laz and spw. This is proposed NTE-TE model for lymphocytes
A = 30 #The area of the cell nucleus for lymphocytes
H=A*Flux
eta = eta0*L*exp(-eta1*L) # Eq. 9 in 18dev_bet
0.0104 + beta*Flux*(1-exp(-H)) + eta*(1-exp(-d/d_0))  #0.00071 + sig*6.24*d/L*(1-exp(-1024*d/L)) + eta*(1-exp(-10^3*d))#don't use
}
#nls (non-linear least square) method to get the parameters needed (4 parameter estimation)
new_Q_IDER_model = nlsLM(CA ~ NTE_Q_function(d, L, eta0, eta1, beta), data = modified_df, start = list(eta0 = 0.001, eta1 = 0.01, beta=3),
weights = (1/(modified_df$error)^2))
NTE_LQ_function = function(d, L, eta0, eta1,alpha, beta) {
Flux=6.242*d/L # rks to laz and spw. This is proposed NTE-TE model for lymphocytes
A = 30 #The area of the cell nucleus for lymphocytes
H=A*Flux
eta = eta0*L*exp(-eta1*L) # Eq. 9 in 18dev_bet
0.0104 +(alpha/d+ beta)*Flux*(1-exp(-H)) + eta*(1-exp(-d/d_0))
}
new_LQ_IDER_model = nlsLM(CA ~ NTE_LQ_function(d, L, eta0, eta1,alpha, beta), data = modified_df, start = list(eta0 = 0.001, eta1 = 0.01, alpha=0.3, beta=2),
weights = (1/(modified_df$error)^2))
IDER = function(d, L, Z.b, eta0, eta1, sig0, kap) {
Flux=6.242*d/L
A = 30 #The area of the cell nucleus for lymphocytes
H=A*Flux
P = (1-exp(-Z.b/kap))^2 #Eq. (7A) in 18_dev_bet; dimensionless "probability"; makes sense for kap > 0
sig = sig0*P + 0.041/6.24*L*(1-P) # Eq. (7B) in 18_dev_bet
eta = eta0*L*exp(-eta1*L) # Eq. 9 in 18dev_bet
0.0104 + sig*Flux*(1-exp(-H)) + eta*(1-exp(-d/d_0))  #0.00071 + sig*6.24*d/L*(1-exp(-1024*d/L)) + eta*(1-exp(-10^3*d))#don't use
}
IDER_model = nlsLM(CA ~ IDER(d, L, Z.b, eta0, eta1, sig0, kap), data = modified_df, start = list(eta0 = 0.001, eta1 = 0.01, sig0 = 15, kap = 445),
weights = (1/(modified_df$error)^2))
calibrated_coef=coef(IDER_model)
summary(IDER_model, cor = T)
summary(new_Q_IDER_model_TEonly)
summary(new_Q_IDER_model)
summary(new_LQ_IDER_model)
L_TE <- resid(new_Q_IDER_model_TEonly) ** 2
L_NTE_Q <- resid(new_Q_IDER_model) ** 2
L_NTE_LQ <- resid(new_LQ_IDER_model) ** 2
L_IDER <- resid(IDER_model) ** 2
#Since all models are weighted least square regression, will weight our model with our weights to get the WRSS (weighted residual squared sum)
WRSS_TE = sum((1/modified_df$error^2)*L_TE)
WRSS_NTE_Q = sum((1/modified_df$error^2)*L_NTE_Q)
WRSS_NTE_LQ = sum((1/modified_df$error^2)*L_NTE_LQ)
WRSS_IDER = sum((1/modified_df$error^2)*L_IDER)
#functions for AIC and BIC calculation for Weighted Least Square regression
AIC_function = function(RSS, k = 4, n = length(modified_df[ , 1])) {
n + n*log(2*pi) + n*log(RSS/n) + 2*(k+1)
}
BIC_function = function(n = length(modified_df[, 1]), k = 4, RSS) {
n + n*log(2*pi) + n*log(RSS/n) + log(n)*(k+1)
}
TE_AIC = AIC_function(RSS = WRSS_TE, k = 1)
NTE_Q_AIC = AIC_function(RSS = WRSS_NTE_Q, k = 3)
NTE_LQ_AIC = AIC_function(RSS = WRSS_NTE_LQ)
IDER_AIC = AIC_function(RSS = WRSS_IDER)
TE_BIC = BIC_function(RSS = WRSS_TE, k = 1)
NTE_Q_BIC = BIC_function(RSS = WRSS_NTE_Q, k = 3)
NTE_LQ_BIC = BIC_function(RSS = WRSS_NTE_LQ)
IDER_BIC = BIC_function(RSS = WRSS_IDER)
information_critera_df = data.frame(Model = c("TE model","NTE_Q model", "NTE_LQ model", "IDER model"), AIC = c(TE_AIC, NTE_Q_AIC, NTE_LQ_AIC, IDER_AIC), BIC = c(TE_BIC, NTE_Q_BIC, NTE_LQ_BIC, IDER_BIC))
arrange(information_critera_df, AIC)
beta0 <- as.numeric(coef(new_Q_IDER_model_TEonly))
MIXTE_function = function(r, L, Z.b, d = seq(0, 0.2, by = 0.001), beta = beta){
dE = function(yini, State, Pars){
n = length(L)
beta = beta0
with(as.list(c(State, Pars)), {
u = numeric(n)
for (i in 1:n){
u[i] = uniroot(function(d) {beta *6.242*d/L[i]*(1 - exp(-30*6.242*d/L[i])) - I}, lower = 0, upper = 0.4, extendInt = "yes", tol = 10^-10)$root
}
dI = numeric(n)
H = numeric(n)
for(i in 1:n){
H[i] = 6.24*30*u[i]/L[i]
dI[i] = r[i]*(beta * 6.24/L[i] * exp(-H[i]) * (exp(H[i]) + H[i] - 1)) #Partial derivative of TE function over d
}
dI = sum(dI)
return(list(c(dI)))
})
}
pars = NULL; yini = c(I = 0); d = d
out = ode(yini,times = d, dE, pars, method = "radau")
return(out)
}
#Here is the TE function again for individual dose
TE_function = function(d, L, beta) {
Flux=6.242*d/L # Eq. (5a) in 18_dev_bet; a model-independent equation for particle flux
A = 30 #The area of the cell nucleus for lymphocytes
H=A*Flux
0 + beta*Flux*(1-exp(-H))
}
r = rep(1/3, 3); L = c(75, 100, 175); Z.b = c(595, 690, 1075); dose = seq(0,.4,by=0.001)
MX = MIXTE_function(r, L, Z.b, d = dose)
plot(MX[,1],MX[,2],type='l',bty='l',col='red',ann='F',ylim=c(0,.10))
for (ii in 1:length(L)){lines(dose,TE_function(dose,L[ii],Z.b[ii]),col='green')}
#SEA
SEA=function(d){
TE_function(d/3,L[1],Z.b[1])+TE_function(d/3,L[2],Z.b[2])+TE_function(d/3,L[3],Z.b[3])
}
lines(dose,SEA(dose),lty=2)
#Here is the TE function again for individual dose
TE_function = function(d, L, beta) {
Flux=6.242*d/L # Eq. (5a) in 18_dev_bet; a model-independent equation for particle flux
A = 30 #The area of the cell nucleus for lymphocytes
H=A*Flux
0 + beta*Flux*(1-exp(-H))
}
r = rep(1/3, 3); L = c(75, 100, 175); Z.b = c(595, 690, 1075); dose = seq(0,.4,by=0.001)
MX = MIXTE_function(r, L, Z.b, d = dose)
plot(MX[,1],MX[,2],type='l',bty='l',col='red',ann='F',ylim=c(0,.50))
for (ii in 1:length(L)){lines(dose,TE_function(dose,L[ii],Z.b[ii]),col='green')}
#SEA
SEA=function(d){
TE_function(d/3,L[1],Z.b[1])+TE_function(d/3,L[2],Z.b[2])+TE_function(d/3,L[3],Z.b[3])
}
lines(dose,SEA(dose),lty=2)
beta
beta0
